The [[CVI]] function decodes a 2-byte [[STRING]] generated by [[MKI$]] (or read from a file) to [[INTEGER]] numeric values.


{{PageSyntax}}
: {{Parameter|result%}} = [[CVI]]({{Parameter|stringData$}})


{{PageDescription}}
* ''CV'' functions ([[CVD]], [[CVS]], [[CVI]], [[CVL]], [[CVDMBF]], [[CVSMBF]]) are used to convert values encoded by ''MK$'' functions ([[MKD$]], [[MKS$]], [[MKI$]], [[MKL$]], [[MKDMBF$]], [[MKSMBF$]]).
* '''QB64''' has [[_CV]] and [[_MK$]] functions which can also deal with extended [[Data types|data types]].
* [[INTEGER]] values can range from -32768 to 32767.
* Doesn't return [[_UNSIGNED]] values.


{{PageExamples}}
''Example 1:''
{{CodeStart}} '' ''
{{Cl|FIELD}} #1, 2 {{Cl|AS}} N$, 12 {{Cl|AS}} B$...
{{Cl|GET}} #1     'GET does not need a position or variable with successive FIELD buffer reads
Y = {{Cl|CVI}}(N$) '' ''
{{CodeEnd}}
:''Explanation:'' Reads a field from file #1, and converts the first two bytes (N$) into an integer number assigned to the variable Y.
:Since the representation of an integer number can use up to 5 ASCII characters (five bytes), writing to a file using [[MKI$]] conversion, and then reading back with the [[CVI]] conversion can save up to 3 bytes of storage space.


''Example 2:'' How CVI converts the ASCII code values created by the MKI$ function.
{{CodeStart}}
{{Cl|SCREEN (statement)|SCREEN}} 12
{{Cl|DIM}} Q {{Cl|AS}} {{Cl|STRING}} * 1
Q = {{Cl|CHR$}}(34)
' create Print using templates to align the values returned 
tmp1$ = "1st character code = ### * 1   =   ### "
tmp2$ = "2nd character code = ### * 256 = ##### "
tmp3$ = "                                 &amp;  "
tmp4$ = "                     CVI Total = ##### "

{{Cl|DO...LOOP|DO}}
  {{Cl|COLOR}} 14: {{Cl|LOCATE}} 13, 20: {{Cl|INPUT}} "Enter an Integer from 1 to 32767(0 quits): ", number%
  {{Cl|IF...THEN|IF}} number% &lt; 1 {{Cl|THEN}} {{Cl|EXIT DO}}
  {{Cl|CLS}}
  ASCII$ = {{Cl|MKI$}}(number%)     ' create the 2 byte character string
  {{Cl|COLOR}} 11
  {{Cl|_PRINTSTRING}} (152, 240), "{{Cl|MKI$}} creates 2 byte ASCII string: " + Q + ASCII$ + Q ' displays character(s)

  asc1% = {{Cl|ASC}}(ASCII$)        ' find the ASCII code values of each character
  asc2% = {{Cl|ASC}}(ASCII$, 2)     ' '''QB64''' allows ASC to read specific characters in a string
 
  {{Cl|LOCATE}} 18, 20: {{Cl|PRINT USING}} tmp1$; asc1%; asc1%
  {{Cl|LOCATE}} 19, 20: {{Cl|PRINT USING}} tmp2$; asc2%; asc2% * 256
  {{Cl|LOCATE}} 20, 20: {{Cl|PRINT USING}} tmp3$; "-----"
  {{Cl|LOCATE}} 21, 20: {{Cl|PRINT USING}} tmp4$; asc1% + (256 * asc2%)
{{Cl|LOOP}}
{{Cl|SYSTEM}} '' ''
{{CodeEnd}}
{{small|Code by Ted Weissgerber}}
:''Explanation:'' All [[ASCII]] characters can be displayed using [[_PRINTSTRING]] . The routine gets the [[ASCII]] code, which is the actual value needed by [[CVI]]. The first byte code is always between 0 and 255. The second byte can return 0 thru 127 and CVI multiplies that value by 256. This proves that you cannot just feed a string number value to [[CVI]] and get the result desired. ("90" gets decoded to 12345).


{{PageSeeAlso}}
* [[MKD$]], [[MKI$]], [[MKS$]], [[MKL$]], [[MKDMBF$]], [[MKSMBF$]]
* [[CVS]], [[CVD]], [[CVL]], [[CVSMBF]], [[CVDMBF]]
* [[_CV]], [[_MK$]]


{{PageNavigation}}
